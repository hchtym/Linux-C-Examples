1.QT作为一种跨平台的图形界面开发平台，可以直接建立在简单的“帧缓冲驱动”上，并
且有良好的可配置、可裁剪性，因此经常用于嵌入式系统上。

2.QT对象
特征：
	有一个字符串形式的名称
	支持信号与槽机制
	能够过滤和接收事件
	支持定时器，启动定时器后每隔一定的时间间隔发生一次定时事件
	实施层次化管理，即对象间有父子关系，父对象保存了所有子对象的指针，子对象保存了父对象的指针
	不能使用复制构造函数和赋值操作符
为了支持上面的一些特性，在编写类的时候需要一些特殊的写法：在类的第一行添加"Q_OBJECT".
Q_OBJECT是一个宏，QT有一个工具moc可以识别这个宏，它会为所有包含Q_OBJECT宏的类生成额外的源代码以
支持QT对象的所有特征。
注意： 如果一个类继承了QObject类，但没有使用任何QT对象的特征，则可以不加Q_OBJECT宏。不过推荐在
       所有QObject的派生类中都加上Q_OBECT.

3.层次化管理
	我们在一个窗口类里面定义一个窗口组件的时候，只是定义个指针，在构造函数里面使用new动态生成，
但是，我们并没有在析构函数里面去释放。这种用法是正确的，因为QT对象游子集的内存管理策略，当父对象被析构时，
它会将它的所有子对象同时析构。因此，只要一个QT对象的父对象设置得当，它就会在父对象析构时自动析构，不许要
做多余的delete。
注意：由于窗口内的部件会在析构时自动调用delete操作符析构，因此这些部件不能定义为成员变量，只能有new动态生成。

4.信号与槽的链接特点：
	1.一个信号可以链接到多个槽函数
	2.一个槽函数可以被多个信号链接
	3.信号也可以链接到信号，此时，前者的调用将导致后者的发射
	4.信号的参数类型必须与槽的参数类型对应，信号的参数可以比槽的参数多，但不可以少，
	  否则链接将失败
注意：定义信号和槽时最好不要包含自定义类型的参数，否则它只能与特定参数类型信号或槽链接，可用性大大降低
需要指出的是，常用的QT对象类中已经定义了很多有用的信号和槽，编程时可以直接使用

5.事件
	事件是QT的另外一种通信机制。事件由两个要素组成，一是接收者，它必须为QT对象；二是事件对象，保存了
	要传递给接收者的信息。事件有两种发送方式，一种为同步方式，在这种方式下，发送事件将直接进入事件处理流程
，事件处理完毕之后，发送操作才成功返回，这种情况下，发送者可以得到事件的处理结果；另一种为异步方式，这种方式下
，发送的事件会进入一个队列，这时发送的操作就成功返回了，队列中的事件有主事件循环取出并进行处理，这种情况下，发
送者无法获得事件处理结果。

6.QDialog
	QDialog类代表对话框，对话框一般只用来实现那些只是暂时存在的用户界面。对话框是独立的窗口，但他通常也有父窗口
，当对话框显示的时候，默认的位置是在父窗口的中央。从外观上来看对话框一般没有最大化、最小化按钮。
	对话框有模态和非模态两种形式。非模态的对话框的行为和使用方法都很类似于普通的窗口。模态对话框显示时，其他窗口将
全部进入非激活状态，不能接受键盘和鼠标的事件。模态又分成两种：
	一种是对整个应用程序模态，这时它的出现将导致程序中的所有窗口失去相应；
	另一种是相对窗口模态，这时仅仅会导致它所在的整个窗口树失去相应。

7.窗口状态
	使能：处于使能状态的窗口才能处理键盘和鼠标等输入事件，反之，处于禁用状态的窗口不能处理这些事件。窗口是否处于使能
		状态有其属性enabled表示，相关函数：
			bool isEnabled() const;
			void setEnabled(bool enable);
			void setDisabled(bool disable);  === setEnable(!enbale)
	窗口的使能状态可能影响外观，比如处于禁用状态的按钮文本显示为灰色；使能状态与窗口的可见性有相似的逻辑：禁用一个窗口
		同时会使它的所有的子窗口成为禁用状态。
	
	激活状态：当有多个独立窗口同时存在时，只有一个窗口能够处于激活状态。系统产生的键盘、鼠标等出入事件将被发送给处于激活
		状态的窗口。一般来说，这样的窗口会被提升到堆叠层次的最上面，除非其他窗口有总在最上面的属性。与之相关的函数：
			bool isActiveWindow() const 
			void activateWindow()

	焦点：用于控制同一个独立窗口内那一个部件可以接受键盘事件，同一时刻只能有一个部件获得焦点。
		void hasFocus() const
		void setFocus()
		void clearFocus()
		QWidget* focusWidget() const  //得到窗口内获得焦点的子窗口