>>>>>>>>>>>>>>>
面向对象的三大特性:
      封装
      继承 
      多态

开闭原则：对修改封闭，对扩展开放

构造一个对象的过程：
     1.分配内存
     2.创建父类的成员变量
     3.调用父类的构造函数
     4.创建子类的成员变量
     5.调用子类的构造函数

我们可以在子类的构造函数中的，初始化列表里面调用特定的父类的构造函数。
构造函数会先调用父类的构造函数；析构函数会先调用子类的析构函数。

>>>>>>>>>>>>
函数名的隐藏
子类中定义一个与父类中成员函数同名的成员函数，叫做“函数名隐藏”，只要函数名相同就可以，不用管参数怎样
子类可以继承父类的static成员函数;另外，子类中的同名函数(包括static和非static)也会覆盖父类的static函数

函数名的隐藏是指在一般类继承的过程中，子类中有和父类成员函数重名(仅满足“重名”即可)时，
通过子类对象调用该同名函数时，会调用子类的方法，而不是父类的方法。这种现象叫“函数名隐藏”.

多重继承
父类对象的继承顺序是按照子类继承父类时的顺序来实现的,如下，则父类构造函数调用的顺序为Phone Mp3 Camera:
class CellPhone:public Phone,public Mp3,public Camera
{};

虚继承 virtual 
当多个类都共有一个父类的情况下，我们可以使用虚继承来实现孙子类中只含有一份爷爷类的成员方法和数据成员。


如果想复用代码，首先考虑使用类的组合，而不是继承。

继承具有的问题？ 
     提高软件的复杂度，可维护性和可扩展性降低
     继承一定情况下会破坏封装，尽量使用组合，而不是使用继承来实现类之间的关系

>>>>>>>>>>>>>>>>
多态polymorphism
函数的覆盖override:
/*
 *编译期绑定(静态绑定)
 *pa的类型是什么？
 *     Animal  编译期类型
 *     Dog     运行期类型
 *
 *在成员函数前面添加virtual，就会使其成为多态函数，要求多态函数完全一样。
 *一旦父类的成员函数前添加了virtual,那么子类的同名函数默认为virtual
 *同名函数实现 覆盖override：
 *           1.函数名相同，参数相同，返回值相同
 *           2.访问权限不能更小
 *           3.抛出的异常不能更多
 */     

>>>>>>>>>>>>>>>>>
括号运算符：函数对象
Class A{
      int operator()(int a,int b,int c)
          { return (a+b+c);}
};
A a(m,n,q);   //a类似函数，但它是对象，所以叫函数对象

在STL中，函数对象应用很广泛。
函数对象比普通的函数有更大的灵活性和通用性。
如:
Class A{
      int t;
public:
      A(t=0):t(t){}
      int operator()(int a,int b,int c)
          { if(t==0)return (a+b+c);
            else if(t==1) return a-b-c;
            else if(t==2) return a*b*c;
            else if(t==3) return a/b/c;
          }
};

A plus(0);
A minus(1);
A mulit(2);
A divide(3);

>>>>>>>>>>>>
类的三大特性：
封装：
     对类的具体的实现细节隐藏，只给外界公开一些必要的访问接口。接口公开的函数，成员变量(可能是常量，静态成员)；
     降低程序之间的耦合度。提高程序的可维护性和可扩展性。


继承：
     类与类之间的关系：
       继承         is a
       组合/聚合     has a

     为什么使用继承？ 
       代码复用
       制定规则
       为了多态
    尽量多用组合少用继承。

多态:
    广义性的多态：
       一个int既可以当float来用，也可以当作double来用
    狭义上的多态：
       父类的指针或者父类的引用，“指向”不同的子类对象。
       函数的多态，通过一个变量(指针/引用)，调用同一个函数，程序会根据对象的不同调用不同类中函数；
       C++中，多态是可选的。如果函数是虚函数，那么就存在多态可能。子类覆盖了父类中的虚函数。
       覆盖只存在于虚函数中，只有虚函数才能被覆盖。(不是虚函数的同名函数叫"名字隐藏")。
   
>>>>>>>>>>>>>
抽象类
如果一个类中有纯虚函数，该类就是抽象类。

纯虚函数：不需要实现函数体的函数成员，写成 "函数名()=0;"的形式
/*含有纯虚函数的类，称为抽象类，不可以定义抽象类的对象*/
/*
 *抽象类不能直接构造出对象，除此之外，可以做任何能做的事情。
 *    做函数的参数，用来声明指针，或是引用类型
 */
class Shape{
public:
        virtual void show()const=0;       /*纯虚函数，没有函数体*/
};

必须在子类里面实现父类的纯虚函数，否则子类也是抽象类，不可定义对象。
抽象类可以作为编程的规则：  定义的子类必须要实现抽象类，否则编译都不通过。
抽象类也可以用于搭建一个框架，然后具体取实现。

抽象类在C++中相当于接口，一般全部都是虚函数。

>>>>>>>>>>>>>>>>>>>
动态绑定的底层实现----虚函数表
本质上,一个对象里面只存放虚函数表的指针，如果是多重继承，那么会保存多个父类虚函数表指针。
      C++通过vtable和动态绑定实现的多态非常高效，对性能的影响很小。
      在一些对性能要求非常高的实时性程序中，不要使用多态

多态可以增加程序的通用性。 

>>>>>>>>>>>>>>>>>
类型信息和类型转换
typeid
可用于在运行时判断对象的信息。
必须在多态体制中运用typeid运算符。

>>>>>>>>>>>>>>>>
如果一个类中有虚函数，那么该类应该同时定义一个虚析构函数！！！